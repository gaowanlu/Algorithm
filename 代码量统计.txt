#include<iostream>
using namespace std;
/*冒泡排序是一种贪心算法策略
每次总大问题中选择一个局部最优解
然后问题规模进一步减小
解决子问题的方法和上一次解决问题方法是一样的
*/ 
void function(int*list,int n){
	int i=0,j=0;
	bool flag=0;
	for(i=0;i<n;++i){
		flag=0;
		for(int j=0;j<n-i-1;j++){
			if(list[j]>list[j+1]){
				flag=1;
				int temp=list[j];
				list[j]=list[j+1];
				list[j+1]=temp;
			}
		}
		if(!flag){
			break;
		}
	} 
}
int main(int argc,char**argv){
	int list[10]={2,4,6,5,3,1,9,7,8,0};
	//将list进行冒泡排序 
	function(list,10);
	int i=0;
	cout<<"list:\n";
	for(i;i<10;++i){
		cout<<"\t"<<list[i]<<endl;
	}
	return 0;
}
#include<iostream>
using namespace std;
//函数功能：冒泡排序 
void BubbleSort(int*list,int n){
	int i=0,j=0;
	bool flag=0;
	for(i=0;i<n;++i){
		flag=0;
		for(j=0;j<n-i-1;++j){
			if(list[j]>list[j+1]){
				flag=1;
				int temp=list[j];
				list[j]=list[j+1];
				list[j+1]=temp; 
			}
		}
		if(!flag){
			break;
		}
	}
}
int main(int argc,char**argv){
	int weight[8]={4,10,7,11,3,5,14,2};//古董清单 
	//我们需要在古董清单每次贪心选择都选择最轻的
	//则我们将其进行非递减排序比较好
	//在此为了写排序比较方面、使用冒泡排序	
	BubbleSort(weight,8);
	//排序输出验证
	int i;
	cout<<"weight:\n";
	for(i=0;i<8;i++){
		cout<<"\t"<<weight[i]<<endl;
	}
	int max=0,sum=0;
	cout<<"请你输入船的限重:";
	cin>>max;
	//开始进行贪心选择
	cout<<"您可以带走重量序列为:\n";
	for(i=0;i<8;i++){
		if(sum+weight[i]<=max){
			cout<<"\t"<<weight[i]<<endl;
			sum+=weight[i];
		}else{
			break;
		}
	} 
	cout<<"带走的总重量为:\n";
	cout<<"\t"<<sum<<endl;
	return 0;
}
#include<iostream>
using namespace std;
//第一眼看背包问题怎么和最优装载问题有些相似呢
//它们都可以利用贪心策略来求解

/*问题:
 假设山洞有n种宝物，每种宝物有一定重量w和相应价值v
 毛驴运载能力有限，只能运走m重量的宝物，一种宝物只能拿走一样，
 宝物可以分割，怎样才能使毛驴运走宝物的价值最大呢？ 
 */
 
 //局部最优：
 //选择性价比最大的宝物 
int main(int argc,char**argv){
	int i=0,j=0;
	//宝物的重量 
	int w[10]={4,2,9,5,5,8,5,4,5,5};
	//宝物的价值 
	int v[10]={3,8,18,6,8,20,5,6,7,15};
	//性价比
	float p[10]={0};
	//计算性价比
	for(i=0;i<10;++i){
		p[i]=(float)v[i]/(float)w[i];
	}
	//与最优装载类似，我们也将性价比进行排序
	for(i=0;i<10;i++){
		for(j=0;j<10-i-1;j++){
			if(p[j]<p[j+1]){
				float temp=p[j];
				p[j]=p[j+1];
				p[j+1]=temp;
				temp=w[j];
				w[j]=w[j+1];
				w[j+1]=temp;
				temp=v[j];
				v[j]=v[j+1];
				v[j+1]=temp;
			}
		}
	}
	//输出验证
	for(i=0;i<10;i++){
		printf("p:%f\n",p[i]);
		printf("\tw:%d\tv:%d\n",w[i],v[i]);
	}
	//毛驴的承载能力
	float max=19.0;
	//记录毛驴现在的承重量 
	float now=0.0;
	//记录拉走的价值
	float sum=0.0;  
	//开始贪心选择
	for(i=0;i<10;i++){//共有10种宝物
		if(now+w[i]<=max){//还能装 
			sum+=v[i];
			now+=w[i];
		}else{//只能装入部分 
			sum+=(max-now)*p[i];
			now+=max-now;
			break;
		}
	}
	//输出拿走的总价值
	printf("sum value is:\n\t%f\n",sum); 
	return 0;
} 
//会议时间表
//会议       1   2   3   4   5   6   7   8   9   10
//开始时间   8   9   10  11  13  14  15  17  18  26  
//结束时间   10  11  15  14  16  17  17  18  20  19
//贪心策略：局部最优解，选择结束最早的
//相容且最早结束
#include<iostream>
using namespace std;
struct Meeting{
	int num;//会议序号 
	float start;//会议开始时间 
	float end;//会议结束时间
	int flag;//记录是否被选中 
};
void printMeeting(struct Meeting*meet,int n){
	int i=0;
	if(!meet||n<=0){
		return;
	}
	for(i=0;i<n;i++){
		printf("DATA:%d:\n",meet[i].num);
		printf("\tstart:%f\n",meet[i].start);
		printf("\tend:%f\n",meet[i].end);
		printf("\tflag:%d\n",meet[i].flag);
	}
} 
int main(int argc,char**argv){
	int i=0,j=0;
	//建立数组存储会议信息
	struct Meeting meet[10]={
		{1,8,10,0},
		{2,9,11,0},
		{3,10,15,0},
		{4,11,14,0},
		{5,13,16,0},
		{6,14,17,0},
		{7,15,17,0},
		{8,17,18,0},
		{9,18,20,0},
		{10,16,19,0}
	};
	//信息输出
	printMeeting(meet,10);
	//我们既然要选择结束最早的，那么我们最好以end将meet进行排序,以便操作
	//在此为了，便于操作数据较少，采用了冒泡排序
	//如果对时间复杂度要求严格，可改进排序算法
	for(i=0;i<10;i++){
		for(j=0;j<10-i-1;j++){
			if(meet[j].end>meet[j+1].end){
				struct Meeting temp=meet[j];
				meet[j]=meet[j+1];
				meet[j+1]=temp;
			}
		}
	}
	//排序后输出
	printf("进行排序后\n");
	printMeeting(meet,10);
	//存储可利用时间段信息
	int time_start=8,time_end=20;
	//开始进行贪心选择
	int now=time_start;//记录可以用时间段的开始时间
	for(i=0;i<10;i++){
		if(meet[i].start>=now&&meet[i].end<=time_end){
			meet[i].flag=1;//选中
			now=meet[i].end;//更新now 
		}else if(meet[i].end>time_end){
			break;
		} 
	}
	//输出会议安排序列
	printf("会议序列为:\n");
	for(i=0;i<10;i++){
		if(meet[i].flag){
			printf("\t%d",meet[i].num);
		}
	} 
	//可见会议安排问题的解并不唯一,当多个会议的end相同
	//且都相容时，我们对其不同选择，会产生不同的结果
	//此题还可能为:1 4 7 8 9 ,同样有5个会议
	//我们可以将一些会议加上权重值，进而解决这种问题 
	return 0;
} 
//迪科斯彻最短路径算法（单源最短路径）
#include<iostream>
using namespace std;
//顶点个数
const int CITY = 5;
//定义无穷
const int INF = 1000;
//使用二维数组存储邻接矩阵
//在此我们直接在源代码中添加邻接矩阵信息
//为了是弄懂程序流程而非实际问题
int map[CITY][CITY]={
{INF,2,5,INF,INF},
{INF,INF,2,6,INF},
{INF,INF,INF,7,1},
{INF,INF,2,INF,4},
{INF,INF,INF,INF,INF}
};
//dist数组与p前驱数组
int dist[CITY]={0};
int p[CITY]={0}; 
//标志数组(表示顶点是否加入了S战队)
int Flag[CITY]={0}; 

//输出路径 
void FindRoad(int last,int origin){
	if(dist[last]==INF){
		printf("Error not find Road\n");
	}
	if(last==origin){
		printf(" %d ",last);
		return;
	}
	FindRoad(p[last],origin);
	printf(" %d ",last);
}

//主函数 
int main(int argc,char**argv){
	int i,j;
	//输出邻接矩阵 
	printf("map:\n");
	for(i=0;i<CITY;i++){
		for(j=0;j<CITY;j++){
			if(map[i][j]==INF)
				printf(" INF ");
			else
				printf(" %d ",map[i][j]);
		}
		printf("\n");
	}
	//选择源点,选择0为源点
	int origin=0;
	//将源点入S战队
	Flag[origin]=1; 
	//初始化dist数组与前驱数组
	for(i=0;i<CITY;i++){ 
		if(i==origin){//dist数组
			dist[i]=0;
			p[i]=-1;
		}else{
			dist[i]=map[origin][i];
			if(map[origin][i]==INF){
				p[i]=-1;
			}else{
				p[i]=origin;
			}
		}
	}
	//输出dist数组与前驱数组
	printf("dist:\n");
	for(i=0;i<CITY;i++){
		printf(" %d ",dist[i]);
	}
	printf("\np:\n");
	for(i=0;i<CITY;i++){
		printf(" %d ",p[i]);
	}	
	printf("\n");
	//我们要选择n次最小dist
	for(i=0;i<CITY;i++){
		//在集合v-s中找dist最小的
		int temp = INF,t=origin;//t为找到的结果
		for(j=0;j<CITY;j++){
			if(Flag[j]==0&&dist[j]<temp){
				temp=dist[j];
				t=j;
			}
		} 
		if(t==origin){//v-s为空 
			break;
		}
		//更新S战队
		Flag[t]=1;
		//更新dist数组与前驱数组,即借东风
		for(j=0;j<CITY;j++){
			if(Flag[j]==0&&map[t][j]<INF){
				if(dist[j]>dist[t]+map[t][j]){
					dist[j]=dist[t]+map[t][j];
					p[j]=t;
				}
			}
		} 
	} 		
	//输出前驱数组
	printf("最短路径前驱数组为\n");
	for(i=0;i<CITY;i++){
		printf(" %d ",p[i]);
	} 
	printf("\n");
	
	//求最短路径我们可以采用递归或者利用栈的方法
	//FindRoad(4,origin);//第一个参数为终点，第二个参数为源点 
	for(i=0;i<CITY;i++){
		FindRoad(i,origin);
		printf("\n");
	} 
	return 0;
} 
//哈夫曼树及其编码 
#include<iostream>
#include<cstdlib>
#include<vector>
using namespace std;
//定义节点抽象数据结构
struct HuffNode{
	float weight;//节点权重 
	int parent;//节点的父节点下标 
	int lchild;//节点的左孩子下标 
	int rchild;//节点的右孩子下标 
	char value;//节点的值 
}; 
typedef struct HuffNode HuffNode;

//打印哈夫曼树信息
void PrintHuffTree(HuffNode*HuffTree,int node_num){
	int i;
	cout<<"HuffTree:\n";
	for(i=0;i<2*node_num-1;++i){
		cout<<"\t"<<HuffTree[i].weight<<" ";
		cout<<HuffTree[i].parent<<" ";
		cout<<HuffTree[i].lchild<<" ";
		cout<<HuffTree[i].rchild<<" ";
		cout<<HuffTree[i].value<<"\n"; 
	}
} 

//哈夫曼编码
void PrintHuffCode(HuffNode*HuffTree,int root,vector<char>&HuffCode){
	//每次递归到左孩子为-1,右孩子为-1就输出编码
	if(HuffTree[root].lchild!=-1||HuffTree[root].rchild!=-1){//没有遇见叶子节点 
		//遍历左子树
		HuffCode.push_back('0');
		PrintHuffCode(HuffTree,HuffTree[root].lchild,HuffCode);
		//遍历右子树
		HuffCode.push_back('1');
		PrintHuffCode(HuffTree,HuffTree[root].rchild,HuffCode);
		//遍历完左子树与右子树后，要将为root节点的编码位删除
		HuffCode.erase(HuffCode.end()-1); 
	}else{//遇到叶子节点 
		cout<<HuffTree[root].value<<":\n\t";
		int i;
		for(i=0;i<HuffCode.size();i++){
			cout<<HuffCode[i];
		}
		cout<<endl;
		//输出root节点编码后,将为root节点的编码位删除 
		HuffCode.erase(HuffCode.end()-1); 
	} 
	return;
}

int main(int argc,char**argv){
	//存储要编码的信息个体数量 
	const int node_num=6;
	//则我们共需要2*node_num-1个节点，因为构建的HuffTree共有node_num个节点
	//使用动态内存申请
	struct HuffNode*HuffTree=(struct HuffNode*)malloc(sizeof(struct HuffNode)*(2*node_num-1));
	if(!HuffTree) return -1;//内存申请失败
	//初始化哈夫曼树原始数据
	int i;
	for(i=0;i<2*node_num-1;++i){
		HuffTree[i].weight=0;
		HuffTree[i].parent=-1;
		HuffTree[i].lchild=-1;
		HuffTree[i].rchild=-1;
	} 
	float weight[node_num]={5,32,18,7,25,13};
	char value[node_num]={'a','b','c','d','e','f'};
	//权值以及节点数据初始化
	for(i=0;i<node_num;++i){
		HuffTree[i].weight=weight[i];
		HuffTree[i].value=value[i];
	} 
	//输出初始化后的哈夫曼树
	PrintHuffTree(HuffTree,node_num);
	
	//开始构建哈夫曼树
	//一共需要node_num-1次合并
	for(i=0;i<node_num-1;i++){
		//找两个最小权重且父节点下标为-1的两个节点
		//遍历找到最大权重
		int j;
		float max_weight=-1;
		for(j=0;j<node_num+i;j++){
			if(max_weight<HuffTree[j].weight){
				max_weight=HuffTree[j].weight;
			}
		} 
		float weight_1=max_weight+1,weight_2=max_weight+1;//存储两个节点的权重
		int index_1=-1,index_2=-1;//存储两个符合要求的节点的下标
		for(j=0;j<node_num+i;j++){//找两小 
			if(HuffTree[j].weight<weight_1&&HuffTree[j].weight<weight_2&&HuffTree[j].parent==-1){//比次小与最小都小 
				weight_2=weight_1;
				index_2=index_1;
				weight_1=HuffTree[j].weight;
				index_1=j;
			}else if(HuffTree[j].weight<weight_2&&HuffTree[j].parent==-1){//比次小小 
				weight_2=HuffTree[j].weight;
				index_2=j;
			}
		} 
		//构建新节点
		HuffTree[index_1].parent=node_num+i;//更新两最小节点的父节点
		HuffTree[index_2].parent=node_num+i;
		//更新新节点权值
		HuffTree[node_num+i].weight=weight_1+weight_2;
		HuffTree[node_num+i].lchild=index_1;//最小 
		HuffTree[node_num+i].rchild=index_2;//次小 
		
	} 
	//输出哈夫曼树信息
	PrintHuffTree(HuffTree,node_num);
	//输出哈夫曼编码(采用递归方法)
	vector<char>huff_code;
	cout<<"HuffCode:\n";
	PrintHuffCode(HuffTree,2*node_num-2,huff_code);
	 
	
	//释放哈夫曼树内存
	free(HuffTree); 
	return 0;
} 
/*Create by Wanlu Gao
* 2021/1/21 
* 实现功能:
* 在此程序中实现的为邻接矩阵存储图Prim最小生成树
*/
#include<iostream>
#include<cstdlib>
using namespace std;
//定义无穷
const int INF=9999; 
//存储图的顶点数 
const int map_dot_num=7;
//初始化邻接矩阵
const int map[map_dot_num][map_dot_num]={
{INF,23,INF,INF,INF,28,36},
{23,INF,20,INF,INF,INF,1},
{INF,20,INF,15,INF,INF,4},
{INF,INF,15,INF,3,INF,9},
{INF,INF,INF,3,INF,17,16},
{28,INF,INF,INF,17,INF,25},
{36,1,4,9,16,25,INF}};

//函数功能：输出邻接矩阵 
void PrintMap(void){
	int i,j;
	cout<<"Map:\n";
	for(i=0;i<map_dot_num;i++){
		cout<<"\t";
		for(j=0;j<map_dot_num;j++){
			if(map[i][j]==INF)
				cout<<" INF";
			else
				cout<<" "<<map[i][j];
		}
		cout<<endl;
	} 
}
int main(int argc,char**argv){
	int i=0,j=0;
	//输出邻接矩阵
	PrintMap();
	//定义集合数组
	int s[map_dot_num]={0};//{0}表示s集合为空集
	//定义起点
	int start=0; 
	//定义lowcost数组
	int lowcost[map_dot_num]={INF};
	//初始化closest数组
	int closest[map_dot_num]={0};
	//首先让起点0加入s集合
	s[start]=1;
	//初始化lowcost数组与closest数组
	for(i=0;i<map_dot_num;i++){
		if(i!=start){
			lowcost[i]=map[i][start];
			closest[i]=start; 
		}else{
			//更新lowcost
			lowcost[i]=0; 
		}
	}
	//使用Prim生成最小树，需要map_dot_num-1选最小边
	for(i=1;i<map_dot_num;i++){
		//在lowcost选一个在v-s，且距离s最小的目标
		int target=start;
		int temp=INF;
		for(j=0;j<map_dot_num;j++){
			if(j!=start&&s[j]==0&&temp>lowcost[j]){
				temp=lowcost[j];
				target=j;
			}
		}
		if(target==start){
			break;//没有找到目标 
		}
		//加入s集合
		s[target]=1;
		//更新lowcost与closest数组
		for(j=0;j<map_dot_num;j++){
			if(j!=start&&s[j]==0&&lowcost[j]>map[target][j]){
				lowcost[j]=map[target][j];
				closest[j]=target;
			}
		} 
	}
	//输出lowcost数组
	cout<<"lowcost[]:\n\t";
	for(i=0;i<map_dot_num;i++){
		cout<<" "<<lowcost[i];
	}
	//输出closest数组
	cout<<"\nclosest[]:\n\t";
	for(i=0;i<map_dot_num;i++){
		cout<<" "<<closest[i];
	}	
	return 0;
}
 #include<iostream>
#include<algorithm>
using namespace std;
struct Data{
	int flag;
};
bool compare(struct Data a,struct Data b){
	return a.flag<b.flag;
}
//二分查找(迭代)
int BinarySearch(int size,struct Data *list,int flag){
	//定义low、high、middle
	int low=0,high=size-1;
	while(low<=high){
		int middle=(low+high)/2;
		if(list[middle].flag==flag){
			return middle;
		}else if(flag<list[middle].flag){
			//更新low与high
			high=middle-1; 
		}else{
			low=middle+1;
		}
	}
	return -1;//没有找到 
}

//二分查找(递归)
int recursionBS(int low,int high,struct Data*list,int flag){
	//判定条件
	if(low>high){
		return -1;//没找到 
	} 
	int middle=(low+high)/2;
	if(list[middle].flag==flag){
		return middle;
	}else if(flag<list[middle].flag){
		return recursionBS(low,middle-1,list,flag);
	}else{
		return recursionBS(middle+1,high,list,flag);
	}
}


 
int main(int argc,char**argv){
	struct Data list[10]={{12},{32},{423},{54},{65},{42},{65},{34},{12},{76}};
	//将数据根据flag进行非递减排序 
	sort(list,list+10,compare);
	//输出
	cout<<"list flag:\n\t["; 
	for(int i=0;i<10;i++){
		cout<<list[i].flag;
		if(i==9){
			cout<<"]\n";
		}else{
			cout<<",";
		}
	}
	//测试
	cout<<"("<<12<<","; 
	cout<<BinarySearch(10,list,12)<<",";
	cout<<recursionBS(0,10-1,list,12)<<")"<<endl;
	cout<<"("<<423<<","; 
	cout<<BinarySearch(10,list,423)<<",";
	cout<<recursionBS(0,10-1,list,423)<<")"<<endl;
	cout<<"("<<65<<","; 
	cout<<BinarySearch(10,list,65)<<",";
	cout<<recursionBS(0,10-1,list,65)<<")"<<endl;	
	cout<<"("<<43<<","; 
	cout<<BinarySearch(10,list,43)<<",";
	cout<<recursionBS(0,10-1,list,43)<<")"<<endl;
	return 0;
}
#include<iostream>
#include<cstdlib>
using namespace std;
struct Data{
	int flag;
};
void MergeFunction(struct Data*list,int low,int middle,int high){
	//申请辅助空间
	int size=high-low;
	struct Data*space=(struct Data*)malloc(sizeof(struct Data)*size);
	int i=low,j=middle+1;
	int now=0;
	while(i<=middle||j<=high){
		if(i<=middle&&j<=high){
			//比较i j flag
			if(list[i].flag<list[j].flag){
				space[now++]=list[i++];
			}else{
				space[now++]=list[j++];
			} 
		}else if(i<=middle){//i迭代全装入space 
			space[now++]=list[i++]; 
		}else{//j迭代装入space 
			space[now++]=list[j++];
		}
	}
	//将space内的内容装入原来列表内
	for(i=low;i<=high;i++){
		list[i]=space[i-low];
	} 
	free(space);
}
void MergeSort(struct Data*list,int low,int high){
	if(low>=high){//=说明只有一个元素不用排序 
		return;
	}
	int middle=(low+high)/2;
	//对middle左边排序
	MergeSort(list,low,middle);
	//对middle右边排序 
	MergeSort(list,middle+1,high);
	//合并
	MergeFunction(list,low,middle,high);
}
int main(int argc,char**argv){
	struct Data list[5]={{34},{5},{2},{7},{10}};
	MergeSort(list,0,4);
	//输出
	for(int i=0;i<5;i++){
		cout<<" "<<list[i].flag;
	} 
	cout<<endl;
	return 0;
}
#include<iostream>
using namespace std;
int main(int srgc,char**argv){
	int n;
	cin>>n;
	if(n%2==0){
		cout<<"sum is "<<0<<endl;
	}else{
		cout<<"sum is "<<-1<<endl;
	}
	return 0;
} 
#include<iostream>
using namespace std;
int main(int argc,char**argv){
	int n;
	//输入n
	cin>>n;
	//判断n是否合法
	if(n<=0||n>11){
		cout<<"Error:n input error\n";
		return -1;
	}
	//一开始sum=0
	int sum=0;
	int now=1;//使用now来记录，迭代到的格子的麦子粒数 
	int i=1;
	for(i=1;i<=n;++i){
		sum+=now;
		now*=2; 
	}
	cout<<"sum is "<<sum<<endl;
	return 0;
}
#include<iostream>
#include<cstdlib>
using namespace std;
//斐波那契数列递归算法
//功能求斐波那契数列第n个元素 
int Fib1(int n){ 
	if(n<1){
		return -1;
	}
	if(n==1||n==2){
		return 1;
	}else{
		return Fib1(n-1)+Fib1(n-2);
	}
} 
int* Fib2(int n){
	if(n<1){//判断n是否合法 
		return NULL;
	}	
	//使用动态内存申请表 
	int *list=(int*)malloc(sizeof(int)*(n+1));//申请表长为n+1 下标为0空间不使用
	list[1]=1;
	list[2]=1;
	//开始迭代计算
	int i=3;
	for(i=3;i<=n;i++){
		list[i]=list[i-1]+list[i-2];
	} 
	return list;
}
int Fib3(int n){
	if(n<1){//判断n是否合法 
		return -1;
	}
	if(n==1||n==2){
		return 1;
	}
	int i=1,v1=1,v2=1;
	//迭代的妙处
	for(i=3;i<=n;++i){
		v2=v1+v2;
		v1=v2-v1;
	}
	return v2;
}
int main(int argc,char**argv){
	cout<<Fib1(15)<<endl;
	//我们会发现这样的算法复杂度极大、如果我们计算Fib1(101)估计要计算一年
	//能不能进行时间复杂度上的优化?
	//这样的问题出在我们每计算一次都要从n递归到1，我们并没有记录中间的所记录的斐波那契数
	//我们进行下一步的改进:详情看Fib2函数 
	//使用Fib2
	int *list=Fib2(15);
	if(list){
		cout<<list[15]<<endl;
		free(list);//释放list空间	
	} 
	//可见时间上我们进行了可见的优化，能不能进行再优化?
	//时间复杂度我们优化到了O(n),空间复杂度也为O(n)
	//我们只需要获得数列第n项的和，完全没有必要去记录1~n-1的数列值
	//这样我们就可以将空间复杂度进行优化:请看Fib3()
	cout<<Fib3(15)<<endl;
	cout<<"Change the world and yourself with code. Hold on, hold on.\n";
	return 0;
}
#include<iostream>
using namespace std;

int main(int argc,char**argv){
	//x+y+z=30
	//3x+2y+z=50
	
	//得2x+y=20
	//进行遍历穷举
	int x,y,z;
	for(x=1;x<=9;x++){
		y=20-2*x;
		z=30-x-y;
		if(3*x+2*y+z==50){//满足要求的阶 
			cout<<"x y z:\n\t"<<x<<" "<<y<<" "<<z<<endl;
		} 
	} 
	return 0;
}
#include<iostream>
using namespace std;
void function_1(void){
	int n=1;
	while(1){
		if(n%2==1&&n%3==2&&n%5==4&&n%6==5&&n%7==0){
			cout<<n<<endl;
			return;
		}else{
			++n;
		}
	}
}
void function_2(void){
	int n=7;
	while(1){
		if(n%2==1&&n%3==2&&n%5==4&&n%6==5&&n%7==0){
			cout<<n<<endl;
			return;
		}else{
			n+=7;
		}
	}
}
int main(int argc,char**argv){
	function_1();
	//进行优化
	function_2();
	return 0;
} 
#include<iostream>
#include<cstdlib>
#include<cmath>
using namespace std;
//验证任意大于2的偶数都可以表示成两个素数之和

//判断一个数是否为素数
/*算法流程:试除法 
用 2、3、4、...、sqrt(n)去除n
如果能被整除则为合数
不能整除则为素数 
*/
bool judge(int n){
	//先对n进行判断
	if(n<=1){
		return 0;
	}
	if(n==2){
		return 1;
	}
	//开始迭代判断
	int i=2;
	int sqrt_n=(int)sqrt((double)n);
	for(i=2;i<=sqrt_n;++i){
		if(n%i==0){
			return 0;
		}
	}
	return 1;
}
//验证猜想_1 
void function_1(void){
	int i,n;
	for(i=4;i<=2000;i+=2){//从4开始验证 
		//将i分解为两个数、这两个数的和等于i
		for(n=2;n<i;n++){//最小的素数为2、从2开始遍历 
			//判断n是否为素数
			if(judge(n)){//n为素数 
				//求出另一个加数
				if(judge(i-n)){//得到一对符合要求的素数 
					cout<<i<<":\n";
					cout<<"\t "<<n<<" "<<i-n<<endl; 
					//对偶数 i 验证成功
					break; 
				} 
			}
		}
		//如果上面的循环体结束后,i==n则对i没有验证成功 
		if(i==n){
			cout<<"Error: "<<i<<endl; 
		} 
	}
}
//验证猜想_2
void function_2(){
	int i,n;
	for(i=4;i<=2000;i+=2){//从4开始验证 
		//将i分解为两个数、这两个数的和等于i
		for(n=2;n<=i/2;n++){//最小的素数为2、从2开始遍历 
			//判断n是否为素数
			if(judge(n)){//n为素数 
				//求出另一个加数
				if(judge(i-n)){//得到一对符合要求的素数 
					cout<<i<<":\n";
					cout<<"\t "<<n<<" "<<i-n<<endl; 
					//对偶数 i 验证成功
					break; 
				} 
			}
		}
		//如果上面的循环体结束后,i==n则对i没有验证成功 
		if(i==n){
			cout<<"Error: "<<i<<endl; 
		} 
	}
} 

//验证猜想_3
void function_3(void){
	//我们可以申请一个表
	int* list=(int*)malloc(sizeof(int)*(2001));//第1个空间不使用
	int i=2;
	for(i=2;i<=1999;++i){
		if(judge(i)){
			list[i]=1;
		}else{
			list[i]=0;
		}
	}
	//进行验证
	int n;
	for(i=4;i<=2000;i+=2){//从4开始验证 
		//将i分解为两个数、这两个数的和等于i
		for(n=2;n<=i/2;n++){//最小的素数为2、从2开始遍历 
			//判断n是否为素数
			if(list[n]&&list[i-n]){//n为素数 
				cout<<i<<":\n";
				cout<<"\t "<<n<<" "<<i-n<<endl; 
				//对偶数 i 验证成功
				break; 
			}
		}
		//如果上面的循环体结束后,i==n则对i没有验证成功 
		if(i==n){
			cout<<"Error: "<<i<<endl; 
		} 
	}
	//释放申请的内存空间
	free(list); 
} 
int main(int argc,char**argv){
	function_1();
	//可见验证猜想是成功的
	//怎样进一步优化算法
	//(1)偶数的分解存在重复
	/*
	i=4 (2*,2) |(3,1)
	i=6 (2,4) (3*,3) (4,2) |(5,1)
	i=8 (2,6) (3,5) (4*,4) (5,3) (6,2) |(7,1)
	有规律可见，除最后一项、从i/2开始出现对称性重复 
	而且最后一项我们会发现、1不是素数。所以我们可以完全不验证最后一项 
	*/
	function_2();
	//可见我们也完美的进行了验证
	
	//怎样再优化?
	//我们可以知道、judge函数调用了不少次呢？
	//而且judge函数作用被重复调用
	function_3(); 
	cout<<"Donald Ervin Knuth 说 \"程序是蓝色的诗!\""<<endl;
	cout<<"持之以恒地学习，没有什么是学不会的，行动起来，没有什么不可以。"; 
	cout<<"趁着年轻加油吧小伙子！实现自己地梦想、而不是将来的上班下班吃饭睡觉上班下班......";
	return 0;
}

#include<iostream>
#include<cstdlib>
using namespace std;
struct Data{
	int flag;
};

//快速排序划分函数,返回基准元素最后的下标 
int Partition(struct Data*list,int low,int high){
	struct Data temp;
	int i=low,j=high,p=low;
	while(i<j){
		//从右向左
		while(j>i&&list[j].flag>list[p].flag){
			j--;
		}
		//进行元素交换
		if(j>i){ 
			temp=list[j];
			list[j]=list[i];
			list[i]=temp;
			p=j;
			i++; 
		} 
		//从左向右
		while(j>i&&list[i].flag<=list[p].flag){
			i++;
		} 
		//进行元素交换
		if(j>i){
			temp=list[i];
			list[i]=list[j];
			list[j]=temp;
			p=i;
			j--;
		} 
	} 
	return p;	
}

//快速排序递归函数
void QuickSort(struct Data*list,int low,int high){
	if(low<high){
		//进行划分
		int middle=Partition(list,low,high);
		//左部分快速排序
		QuickSort(list,low,middle-1);
		//右部分快速排序
		QuickSort(list,middle+1,high);	
	}
} 


//优化后的划分函数
//我们不用向左扫描，交换，向右扫描，交换
//我们完全可以向左扫描，向右扫描，然后交换 
int Partition_Pro(struct Data*list,int low,int high){
	struct Data temp;
	struct Data base=list[low];
	int i=low,j=high;
	while(i<j){
		//向左扫描
		while(i<j&&list[j].flag>base.flag){
			j--;
		} 
		//向右扫描
		while(i<j&&list[i].flag<=base.flag){
			i++;
		} 
		//交换
		if(i<j){
			temp=list[i];
			list[i]=list[j];
			list[j]=temp;
		}
	}
	//将基准元素放到正确位置
	if(list[i].flag>base.flag){//基准元素小于i,j的位置flag，则要将基准元素放在i-1位置 
		temp=list[i-1];
		list[i-1]=list[low];
		list[low]=temp;
		return i-1;
	}else{//交换i与low 
		temp=list[i];
		list[i]=list[low];
		list[low]=temp;
		return i;
	}
	
}

//快速排序Pro
void QuickSort_Pro(struct Data*list,int low,int high){
		if(low<high){
		//进行划分
		int middle=Partition(list,low,high);
		//左部分快速排序
		QuickSort(list,low,middle-1);
		//右部分快速排序
		QuickSort(list,middle+1,high);	
	}
} 

//测试函数
void Test(int method){
		struct Data list[10];
	//测试数据加载 
	for(int i=0;i<10;i++){
		if(i%2==0){
			list[i].flag=i*3;                                     
		}else{
			list[i].flag=i;
		}
	}
	cout<<"Test Data:";
	for(int i=0;i<10;++i){
		cout<<" "<<list[i].flag;
	}
	//进行快速排序 
	if(!method)
		QuickSort(list,0,9);
	else
		QuickSort_Pro(list,0,9);
	cout<<"\nUse QuickSort:";
	for(int i=0;i<10;++i){
		cout<<" "<<list[i].flag;
	}
	cout<<endl;
} 
int main(int argc,char** argv){
	Test(0);
	Test(1);
	return 0;
}
//大整数乘法 
#include<cstdlib>
#include<cstdlib>
#include<cstring>
#include<iostream>
using namespace std;
const int M =1000;
//存放两个要乘的大数 
char A[M];
char B[M];

struct Node{
	char num[M];
	int l;//记录长度 
	int c;//记录次幂 
};

//分解函数
//功能将old内从下标index及后面共size位装入target 
void decompose(struct Node&old,struct Node&target,int index,int size){
	for(int i=index,j=0;j<size;j++,i++){
		target.num[j]=old.num[i];
	}
	//更新target的长度与次幂
	target.l=size;
	target.c=index+old.c;//取出来部分的次幂等于原来次幂数加没有取得低位数
	//从index下标开始取则将错过了index位低位数据 
}

//相加函数
//功能:将两个有次幂的数进行相加
//即 C+A+B
//以673*10^2 + 98*10^4
//0  0 | 0 0 8 9 （左侧补零） 
//0  0 | 3 7 6 0 （右侧补零）
//加法计算
/*0 0 8 9
+ 3 7 6 0
= 3 7 4 0 1
则  673*10^2 + 98*10^4 = 10473*10^2
*/ 
void add(struct Node &A,struct Node &B,struct Node&C){
	//首先确定那个数的次幂高与低，以便计算
	if(A.c<B.c){
		struct Node temp=A;
		A=B;
		B=temp;
	} 
	//确保A的次幂大于等于B的次幂
	//C的次幂则为A与B低的次幂
	C.c=B.c;
	//计算A + B的结果值最多一共多少位
	int c_length=0;
	if(A.c+A.l>B.c+B.l){
		c_length=A.c+A.l;
	}else{
		c_length=B.c+B.l;
	}
	//计算A左侧需要补零的数量:高幂减低幂 
	int A_left_zeros_num= A.c-B.c;
	int cc=0;//记录进位
	//结果的数值部分最大长度为总长度 c_length - 低幂
	int i=0;
	for(i=0;i<c_length-C.c;i++){
		int ta=0,tb=0;
		if(i<A_left_zeros_num){
			ta=0;//A左侧补零 
		}else{
			ta=A.num[i-A_left_zeros_num]-48;
		}
		if(i<B.l){
			tb=B.num[i]-48;
		}else{//B右侧补零 
			tb=0;
		}
		if(i>=A.l+A_left_zeros_num){
			ta=0;
		}
		C.num[i]=((ta+tb+cc)%10)+48;
		cc=(ta+tb+cc)/10;
	} 
	if(cc){//进位处理 
		C.num[i++]=cc+48;
	}
	C.l=i;
} 



//大数 A mul B函数，分治核心函数 
void mul(struct Node A_node,struct Node B_node,struct Node&AmulB_node){
	if(A_node.l/2==0||B_node.l/2==0){//(递归出口): A B两个数中有1位数的 
		if(A_node.l/2==0){//如果数A的长度为1，则将A B交换，A的长度大于等于B的长度 
			struct Node temp=A_node;
			A_node=B_node;
			B_node=temp;
		}
		//计算结果的次幂(等于两数次幂相加)
		AmulB_node.c=A_node.c+B_node.c;
		//现在我们已经确保数B只有一位
		//计算A*B
		int cc=0;//使用cc记录进位
		int i=0;
		for(i=0;i<A_node.l;i++){//乘法迭代 
			AmulB_node.num[i]=(((B_node.num[0]-48)*(A_node.num[i]-48)+cc)%10)+48;
			cc=((B_node.num[0]-48)*(A_node.num[i]-48)+cc)/10;
		}
		//如果最后进位不为0则要处理进位
		if(cc){
			AmulB_node.num[i++]=cc+48;
		} 
		AmulB_node.l=i;
		//cout<"mul "<<AmulB_node.num<<endl;
		return;//递归出口 
	}
	//进行分解
	struct Node A_low_node,A_high_node;
	struct Node B_low_node,B_high_node;
	decompose(A_node,A_low_node,0,A_node.l/2);//A低位 
	decompose(A_node,A_high_node,A_node.l/2,A_node.l-(A_node.l/2));//A高位 
	decompose(B_node,B_low_node,0,B_node.l/2);//B低位 
	decompose(B_node,B_high_node,B_node.l/2,B_node.l-(B_node.l/2));//B高位 
	//处理(将四部分相乘)
	struct Node t1,t2,t3,t4;
	mul(A_high_node,B_high_node,t1);
	mul(A_high_node,B_low_node,t2);
	mul(A_low_node,B_high_node,t3);
	mul(A_low_node,B_low_node,t4); 
	//合并
	struct Node temp;
	add(t1,t2,AmulB_node);
	add(t3,AmulB_node,temp);
	add(temp,t4,AmulB_node);
}

int main(int argc,char**argv){
	struct Node A_node,B_node,AmulB_node;  
	cout<<"输入大数A: ";
	cin>>A;
	cout<<"输入大数B: ";
	cin>>B;
	cout<<"大数A: "<<A<<endl;
	cout<<"大数B: "<<B<<endl;
	//处理A
	for(int j=strlen(A)-1,i=0;j>=0;i++,j--){//数值处理 
		A_node.num[i]=A[j];
	}
	A_node.c=0;//次幂处理
	A_node.l=strlen(A);//长度处理
	//处理B
	for(int j=strlen(B)-1,i=0;j>=0;i++,j--){//数值处理 
		B_node.num[i]=B[j];
	}
	B_node.c=0;//次幂处理
	B_node.l=strlen(B);//长度处理 
	//输出Anum
	cout<<endl;
	for(int i=0;i<A_node.l;i++){
		cout<<A_node.num[i];
	} 
	cout<<endl;
	//输出Bnum
	for(int i=0;i<B_node.l;i++){
		cout<<B_node.num[i];
	} 
	cout<<endl;
	//计算A*B
	mul(A_node,B_node,AmulB_node);
	//输出计算结果
	cout<<endl;
	for(int i=AmulB_node.l-1;i>=0;i--){
		cout<<AmulB_node.num[i];
	} 
	cout<<endl;
	return 0;
}




